<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CROSS-SITE SCRIPTING(XSS)</title>
</head>
<body>

<section id="team">
<h2>Team members</h2>
<p>Tashrif Radin Ali</p> 
<p>Mohith Krishnamoorthy Jeganathan</p> 
<p>Bruce Wyatt Placathose</p> 
<p>Nahid Sekander</p> 
<p>Suman Rani</p>
<hr>
</section>

<section id="definition">
  <p>Cross-site scripting (XSS) is a type of web application security vulnerability. XSS allows attackers to inject malicious scripts, most commonly client-side JavaScript, into websites. 
    These malicious scripts are executed by the victim's web browser when the browser loads the web page. The scripts can be used to steal sensitive data, manipulate website behavior, or even redirect users to malicious sites.</p>


</section>

<section id="targets">
  <p>XSS poses a significant threat because it targets a broad range of users, from individuals to large organizations that rely heavily on web applications.
    
    JavaScript XSS attacks are often used to access sensitive information because JavaScript has access to a visitor's browser cookies. 
    Attackers can use XSS to use stolen cookies to impersonate the visitor online. Attackers can also use this method to gain access to a user's webcam data, 
    geolocation information, and other personal information such as bank account numbers.
    
    For larger organizations, cross-site scripting attacks can result in severe consequences, including data breaches, financial loss, and reputational damage. 
    Understanding and mitigating XSS vulnerabilities is essential for maintaining secure web applications.</p>

</section>

<section id="cases">

</section>

<section id="examples">
<h2>Examples of XSS exploits</h2>
<h3>Example 1: Basic Script Injection</h3>
<code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code>
<p>This is a simple example where an attacker injects a script that triggers an alert box.</p>
<h3>Example 2: Image Tag with oneerror</h3>
<code>&lt;img src="invalid.jpg" onerror=alert('XSS')&gt;</code>
<p>This example uses an image tag with an invalid source to trigger the onerror event, executing the alert.</p>
<h3>Example 3: Link Injection with Javascript</h3>
<code>&lt;a href="javascript:alert('XSS')"&gt;Click me&lt;/a&gt;</code>
<p>This example shows how an attacker can create a link that executes JavaScript when clicked.</p>
<h3>Example 4: Inline Event Handler Injection</h3>
<code>&lt;button onclick=alert('XSS')&gt;Click me&lt;/button&gt;</code>
<p>This example demonstrates how an attacker can inject JavaScript into an inline event handler of a button.</p>
<h3>Example 5: Using ifram to laod Malicious pages</h3>
<code>&lt;iframe src="javascript:alert('XSS')"&gt;&lt;/iframe&gt;</code>
<h3>Example 6: Injecting into URL Parameters </h3>
<code>http://example.com/page?param=&lt;script&gt;alert('XSS')&lt;/script&gt;</code>
<p>This example shows how an attacker can inject a script into a URL parameter, which may be executed by the server or client-side code.</p>
<h3>Example 7: Breaking out of HTML Attributes </h3>
<code>&lt;input type="text" value="&lt;script&gt;alert('XSS')&lt;/script&gt;"&gt;</code>
<p>This example demonstrates how an attacker can break out of an HTML attribute to inject a script.</p>
<h3>Example 8: JavaScript Injection in JSON</h3>
<code>{ "data": "&lt;script&gt;alert('XSS')&lt;/script&gt;" }</code>
<p>This example shows how an attacker can inject a script into JSON data, which may be executed by the client-side code.</p>
<h3>Example 9: DOM-Based XSS, Client-side only</h3>
<code>document.body.innerHTML = location.hash;</code> <br>
<code>file:///path-to-your-html.html#&lt;img src=x onerror=alert('XSS')&gt;</code>
<p>This example shows how an attacker can manipulate the DOM using the hash part of the URL to inject a script.</p>
<h3>Example 10: Obfuscated JavaScript</h3>
<code>&lt;SCR&lt;script&gt;IPT&gt;alert('XSS')&lt;/SCR&lt;script&gt;IPT&gt;</code>
<p>This example demonstrates how an attacker can obfuscate JavaScript code to bypass filters.</p>
<p>Source: <a href="https://pentest-tools.com/blog/xss-attacks-practical-scenarios ">10 Practical scenarios for XSS attacks </a></p>
<hr>
</section>

<section id="protection">
     <!-- 
        
        Citation
        
        1. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
        2. https://portswigger.net/web-security/cross-site-scripting/preventing
        3. https://www.cloudflare.com/learning/security/how-to-prevent-xss-attacks/
        4. https://www.acunetix.com/websitesecurity/cross-site-scripting/
        
        -->
        <h2>How to Prevent XSS</h2>
        <p>Cross-site scripting (XSS) prevention:</p>
        <ul>
          <li><strong>Output Encoding:</strong> Encode user data before inserting it into the page.</li>
          <li><strong>Input Validation:</strong> Strictly validate user input on arrival.</li>
          <li><strong>Sanitize Data:</strong> Sanitize any HTML input before displaying it to users. Use libraries like <code>DOMPurify</code> to remove or neutralize malicious code.</li>  
        </ul>
      
        <p>Tools like <strong>Burp Scanner</strong> can detect XSS vulnerabilities by simulating real attack behavior.</p>
      
        <h3>1. Encode Data on Output</h3>
        <p>Always encode user input based on the context it is being used in:</p>
        <ul>
          <li><strong>HTML:</strong> Encode <code>&lt;</code> as <code>&amp;lt;</code>, <code>&gt;</code> as <code>&amp;gt;</code>.</li>
          <li><strong>JavaScript Strings:</strong> Use Unicode escapes, e.g., <code>&lt;</code> becomes <code>\u003c</code>.</li>
          <li><strong>Event Handlers:</strong> Apply both JavaScript and HTML encoding in order.</li>
        </ul>
      
        <h3>2. Validate Input on Arrival</h3>
        <p>Validation helps stop invalid or harmful input early:</p>
        <ul>
          <li>Ensure URLs use safe protocols like <code>http</code> or <code>https</code>.</li>
          <li>Validate that numeric inputs are truly numbers.</li>
          <li>Allow only expected characters (whitelisting).</li>
        </ul>
      
        <p><strong>Whitelisting</strong> is preferred over blacklisting to block unapproved input safely and reliably.</p>
      
        <h3>3. Allowing "Safe" HTML</h3>
        <p>Allowing user HTML (e.g., for comments) is risky. Use libraries like <strong>DOMPurify</strong> to sanitize input and remove dangerous tags and attributes. Markdown converters are another option but must be kept updated for security.</p>
      
        <aside>
          <strong>Note:</strong> CSS and even regular HTML can also be used for attacks in certain contexts.
        </aside>
      
        <h3>4. Template Engines</h3>
        <p>Most modern template engines offer built-in escaping mechanisms:</p>
        <ul>
          <li><strong>Twig:</strong> <code>{{ user.firstname | e('html') }}</code></li>
          <li><strong>Jinja/React:</strong> Escape user content by default.</li>
        </ul>
        <p>Avoid direct string concatenation with user input to prevent template injection.</p>
      
        <h3>5. Preventing XSS in PHP</h3>
        <p>Use <code>htmlentities()</code> with the correct flags for output encoding:</p>
        <pre><code>&lt;?php echo htmlentities($input, ENT_QUOTES, 'UTF-8'); ?&gt;</code></pre>
        <p>To escape JavaScript values, implement a custom Unicode-escape function or use template engines instead.</p>
      
        <h3>6. JavaScript-Side Protection</h3>
        <p>Use your own encoder to escape input for safe HTML or JavaScript rendering:</p>
        <pre><code>function htmlEncode(str) {
        return str.replace(/[^\w. ]/g, c =&gt; '&#' + c.charCodeAt(0) + ';');
      }</code></pre>
      
        <pre><code>function jsEscape(str) {
        return str.replace(/[^\w. ]/g, c =&gt; '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4));
      }</code></pre>
      
        <h3>7. jQuery Considerations</h3>
        <p>Avoid injecting untrusted data into jQuery selectors. Use <code>jsEscape()</code> to escape such input. Modern jQuery patches have improved safety, but caution is still necessary.</p>
      
        <h3>8. Mitigating XSS with CSP</h3>
        <p><strong>Content Security Policy (CSP)</strong> helps prevent the execution of malicious scripts if XSS occurs. Example header:</p>
        <pre><code>Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; frame-src 'none'; base-uri 'none';</code></pre>
        <p>Use <strong>nonces</strong> or <strong>hashes</strong> to allow only specific scripts and prevent attackers from injecting code.</p>
     
        <h3>9. Don't Trust Any User Input</h3>
        <p>All user input should be treated as untrusted. Any user input that is used as part of HTML output introduces the risk of an XSS (Cross-Site Scripting) attack. User input, whether from authenticated or internal users, should be sanitized and escaped in the same way as input from public sources.</p>

        <h3>10. HTTPOnly Cookies</h3>
        <p>Mark cookies as <strong>HttpOnly</strong> to prevent JavaScript access</p>
        <pre><code>Set-Cookie: sessionid=abc123; HttpOnly</code></pre>
</section>

</body>
</html>